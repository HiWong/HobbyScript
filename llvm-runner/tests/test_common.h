//
// Created by 刘丰恺 on 20/1/2020.
//

#ifndef LLVM_RUNNER_TEST_COMMON_H
#define LLVM_RUNNER_TEST_COMMON_H

#include <fstream>
#include <iterator>
#include <string>
#include <algorithm>
#include <llvm/ExecutionEngine/ExecutionEngine.h>
#include <llvm/IR/LegacyPassManager.h>
#include "common/common.h"
#include "ast/ast_nodes.hpp"
#include "parser/hobby.tab.hpp"
#include "runtime/runtime.h"
#include "test_config.h"
#include "common/gen_graph.h"
#include "CxxApiWriterPass.h"

extern "C" FILE *yyin;
extern "C" int yyparse(void);
const QString TAG = "[Test Common]: ";
//const constexpr auto separator = std::filesystem::path::preferred_separator;

static void llvm_init() {
    llvm::InitializeNativeTarget();
    llvm::InitializeNativeTargetAsmPrinter();
    llvm::InitializeNativeTargetAsmParser();
}

static AstPackage *test_ast_parse(const QString &fileName) {
    // save context.
    auto *old_package = ast_current_package;
    ast_current_package = new AstPackage();
    auto old_line_num = yylineno;
    yylineno = 0;

    // set open file.
    yyin = fopen(fileName.toUtf8().constData(), "r");
    if (!yyin) {
        throw create_runtime_error(TAG + "could not open file name: " + fileName);
    }
    if (0 != yyparse()) {
        throw create_runtime_error(TAG + "parse " + fileName + "error");
    }

    fclose(yyin);

    // restore context;
    auto *now_package = ast_current_package;
    ast_current_package = old_package;
    // save package message.
    global_packages[fileName] = now_package;
    return now_package;
}

static AstContext *test_parse(const QString &fileName, llvm::Module *module) {
    return global_packages_contexts[fileName] = test_ast_parse(fileName)->compile(module);
}

static void test_llvm_run(AstPackage *package, std::unique_ptr<llvm::Module> module, char *const *envp) {
    atexit(llvm::llvm_shutdown); // Call llvm_shutdown() on exit.

    print_llvm_modules(module.get());
//    output_llvm_modules(module.get());

    if (!package) {
        console->error(QString(TAG + " package is null.").toStdString());
        return;
    }

    llvm::Function *package_func = package->package_function();
    llvm::ExecutionEngine *engine = build_llvm_engine(std::move(module));
    if (!engine) {
        console->error(QString(TAG + " build execute engine is null.").toStdString());
        return;
    }

    Plugins::link_plugins(engine);

    engine->RegisterJITEventListener(llvm::JITEventListener::createOProfileJITEventListener());
    engine->RegisterJITEventListener(llvm::JITEventListener::createIntelJITEventListener());

    std::vector<std::string> noargs = {};
    engine->runFunctionAsMain(package_func, noargs, envp);
}

static int gen_cpp_from_ir(const QString &fileName, bool IR = true, bool Short = false) {
    llvm::LLVMContext Context;
    // Get the output stream
    std::error_code EC;
    llvm::raw_fd_ostream Out((fileName + ".cpp").toStdString(), EC, llvm::sys::fs::F_None);
    if (EC) {
        llvm::errs() << "Error: Unable to open output file: " << EC.message() << "\n";
        return 1;
    }

    // Compile input file
    llvm::SMDiagnostic Err;
    auto M = llvm::parseIRFile(fileName.toStdString(), Err, Context);
    if (!M) {
        Err.print(nullptr, llvm::errs());
        return 1;
    }

    Out << "//\n";
    Out << "// This file is generated by `llvm-cxxapi` based on LLVM "
        << LLVM_VERSION_STRING << "\n"
        << "// , so it may not be compatible with other LLVM versions. If any "
           "errors occur\n// during compilation, it is recommended that you "
           "recompile `llvm-cxxapi` with \n// the specified LLVM version.\n"
           "// https://github.com/zhangjiantao/llvm-cxxapi\n";
    Out << "//\n";
    Out << "// Generate Command:\n";
    Out << "//\n";
    Out << "//   llvm-cxxapi -ir=" << IR << " -short=" << Short << " -o "
        << (fileName + ".cpp").toStdString() << " " << fileName.toStdString() << "\n";
    Out << "//\n";

    // Run cpp writer pass
    llvm::legacy::PassManager PM;
    PM.add(createCxxApiWriterPass(Out, IR, Short));
    PM.run(*M);

    llvm::llvm_shutdown();
    return 0;
}

static std::ofstream create_test_output(const QString &fileName) {
    return std::ofstream(fileName.toUtf8().toStdString());
}

static QString get_graph_gen_path() {
    return get_test_project_dir() + separator + "test_graph_gen";
}

static QString get_test_parse_input() {
    return get_test_project_dir() + separator + "test_parse_input";
}

static QString get_test_graph_gen_validate() {
    return get_test_project_dir() + separator + "validate_graph_gen";
}

static bool compare_file(const std::string &p1, const std::string &p2) {
    std::ifstream f1(p1, std::ifstream::binary | std::ifstream::ate);
    std::ifstream f2(p2, std::ifstream::binary | std::ifstream::ate);

    if (f1.fail() || f2.fail()) {
        return false; //file problem
    }

    if (f1.tellg() != f2.tellg()) {
        return false; //size mismatch
    }

    //seek back to beginning and use std::equal to compare contents
    f1.seekg(0, std::ifstream::beg);
    f2.seekg(0, std::ifstream::beg);
    return std::equal(std::istreambuf_iterator<char>(f1.rdbuf()),
                      std::istreambuf_iterator<char>(),
                      std::istreambuf_iterator<char>(f2.rdbuf()));
}

#endif //LLVM_RUNNER_TEST_COMMON_H
